<!doctype html>
<html>
	<head>
		<meta charset="utf-8" />
		<title>Combat</title>
		<style>
			html, body {
				width: 100%;
				height: 100%;
			}

			body {
				background-color: #ffffff;
				margin: 0;
				overflow: hidden;
				font-family: arial;
			}
		</style>
	</head>
	<body>

		<div id="container">


		</div>

	</body>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
	<script src="js/three.min.js"></script>
	<script src="js/cannon.js"></script>
	<script src="js/PointerLockControls.js"></script>
	<script>
		var sphereShape, sphereBody, world, physicsMaterial;

		var camera, scene, renderer, objects = [];
		var geometry, material, mesh;
		var controls,time = Date.now();

		var havePointerLock = 'pointerLockElement' in document || 
			'mozPointerLockElement' in document || 
			'webkitPointerLockElement' in document;

		if ( havePointerLock ) {
			var element = document.body;

			 var pointerlockchange = function ( event ) {
				if ( document.pointerLockElement === element || 
						document.mozPointerLockElement === element || 
						document.webkitPointerLockElement === element ) {
					controls.enabled = true;
				} else {
					controls.enabled = false;
				}
			}
			
			// Hook pointer lock state change events
			document.addEventListener( 'pointerlockchange', pointerlockchange, false );
			document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
			document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );
			window.addEventListener( 'resize', onWindowResize, false );
			document.addEventListener( 'click', function(event) {
				element.requestPointerLock = element.requestPointerLock || 
										  element.mozRequestPointerLock || 
										  element.webkitRequestPointerLock;
				element.requestPointerLock();
			});
		}
		
		
		initCannon();
		init();
		animate();

		
			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}
		
		function initCannon(){
			// Setup our world
			world = new CANNON.World();
			world.quatNormalizeSkip = 0;
			world.quatNormalizeFast = false;

			var solver = new CANNON.GSSolver();

			world.defaultContactMaterial.contactEquationStiffness = 1e9;
			world.defaultContactMaterial.contactEquationRegularizationTime = 3;

			solver.iterations = 7;
			solver.tolerance = 0.1;

			world.solver = new CANNON.SplitSolver(solver);

			world.gravity.set(0,-40,0);
			world.broadphase = new CANNON.NaiveBroadphase();

			// Create a slippery material (friction coefficient = 0.0)
			physicsMaterial = new CANNON.Material("physicsMaterial");
			var physicsContactMaterial = new CANNON.ContactMaterial(physicsMaterial,
																	physicsMaterial,
																	0.4, // friction coefficient
																	0.3  // restitution
																	);
			// We must add the contact materials to the world
			world.addContactMaterial(physicsContactMaterial);

			// Create a sphere
			var mass = 50, radius = 1.3;
			sphereShape = new CANNON.Sphere(radius);
			sphereBody = new CANNON.RigidBody(mass,sphereShape,physicsMaterial);
			sphereBody.position.set(0,radius,0);
			//sphereBody.linearDamping = 0.9;
			world.add(sphereBody);

			// Create a plane
			var groundShape = new CANNON.Plane();
			var groundBody = new CANNON.RigidBody(0,groundShape,physicsMaterial);
			groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),-Math.PI/2);
			world.add(groundBody);
		}

		function init() {
			camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

			scene = new THREE.Scene();
			scene.fog = new THREE.Fog( 0x000000, 0, 500 );

			var ambient = new THREE.AmbientLight( 0x222222 );
			scene.add( ambient );

			light = new THREE.SpotLight( 0xffffff );
			light.position.set( 10, 30, 20 );
			light.target.position.set( 0, 0, 0 );

			light.castShadow = true;

			light.shadowCameraNear = 20;
			light.shadowCameraFar = 50;//camera.far;
			light.shadowCameraFov = 40;

			light.shadowMapDarkness = 0.8;
			light.shadowMapWidth = 2*512;
			light.shadowMapHeight = 2*512;
			light.shadowCameraVisible = true;
			scene.add( light );
			
			controls = new PointerLockControls( camera , sphereBody );
			scene.add( controls.getObject() );

			// floor
			geometry = new THREE.PlaneGeometry( 300, 300, 50, 50 );
			geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

			material = new THREE.MeshLambertMaterial( { color: 0xdddddd } );

			mesh = new THREE.Mesh( geometry, material );
			mesh.castShadow = true;
			mesh.receiveShadow = true;
			scene.add( mesh );

			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.shadowMapEnabled = true;
			renderer.shadowMapSoft = true;
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setClearColor( scene.fog.color, 1 );

			document.body.appendChild( renderer.domElement );
			
			
			// Add boxes
			var halfExtents = new CANNON.Vec3(1,1,1);
			var boxShape = new CANNON.Box(halfExtents);
			var boxGeometry = new THREE.CubeGeometry(halfExtents.x*2,halfExtents.y*2,halfExtents.z*2);
			boxBody = new CANNON.RigidBody(5,boxShape);
			boxMesh = new THREE.Mesh( boxGeometry, material );
			world.add(boxBody);
			scene.add(boxMesh);
			boxBody.position.set(10,10,10);
			boxMesh.position.set(10,10,10);
			boxMesh.castShadow = true;
			boxMesh.receiveShadow = false;
			boxMesh.useQuaternion = true;
			objects.push(boxMesh);
			
		}
		
		var dt = 1/60;
		function animate() {
			requestAnimationFrame( animate );
			if(controls.enabled){
				world.step(dt);
			}
			boxBody.position.copy(boxMesh.position);
			boxBody.quaternion.copy(boxMesh.quaternion);


			controls.update( Date.now() - time );
			renderer.render( scene, camera );
			time = Date.now();
		}
		
		
	</script>
</html>